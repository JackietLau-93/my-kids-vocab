<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>TinyVocab Time Traveler</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Jua&family=Noto+Sans+SC:wght@500;700&family=Noto+Sans+TC:wght@500;700&family=Zen+Maru+Gothic:wght@500;700&display=swap" rel="stylesheet">

<style>
    :root {
        /* Semantic Colors */
        --c-animal: #7CB342; --c-food: #FDD835; --c-body: #42A5F5; 
        --c-home: #EF5350; --c-act: #AB47BC;
        
        /* Grammar Colors */
        --pos-noun: #2196F3; --pos-verb: #F44336; --pos-adj: #4CAF50;
        --pos-adv: #F9A825; --pos-pron: #9C27B0; --pos-prep: #E91E63; --pos-conj: #FF9800;
        
        --bg: #F2F2F2; --card-bg: #FFFFFF;
        
        /* Level Colors (Spectrum) */
        --lvl-1: #4CAF50; --lvl-2: #FF9800; --lvl-3: #F44336; 
        --lvl-4: #9C27B0; --lvl-5: #673AB7; --lvl-6: #3F51B5;
        --lvl-7: #2196F3; --lvl-8: #00BCD4; --lvl-9: #009688;
    }

    body { font-family: 'Zen Maru Gothic', sans-serif; background: var(--bg); margin: 0; color: #333; -webkit-font-smoothing: antialiased; }

    /* FONTS */
    .font-en, .font-fr, .font-de, .font-it, .font-ru { font-family: 'Fredoka One', cursive; }
    .font-ja { font-family: 'Zen Maru Gothic', sans-serif; font-weight: 700; }
    .font-ko { font-family: 'Jua', sans-serif; }
    .font-zh-cn { font-family: 'Noto Sans SC', sans-serif; font-weight: 700; letter-spacing: 1px; }
    .font-zh-tw { font-family: 'Noto Sans TC', sans-serif; font-weight: 700; letter-spacing: 1px; }

    /* HEADER */
    header { 
        background: rgba(255,255,255,0.98); padding: 10px 20px; 
        position: sticky; top: 0; z-index: 100;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        display: flex; flex-direction: column; gap: 8px;
    }
    .top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap; gap: 10px;}
    
    #lang-select { padding: 8px 12px; border: 1px solid #ddd; border-radius: 20px; font-family: 'Zen Maru Gothic'; font-weight: bold; outline: none; }
    .btn { padding: 8px 16px; border: 1px solid #ddd; border-radius: 20px; cursor: pointer; background: white; font-family: 'Fredoka One'; color: #555; font-size: 0.85rem;}
    .btn-primary { background: #333; color: white; border-color: #333; }

    /* LEVEL SLIDER */
    .level-container { display: flex; align-items: center; gap: 15px; width: 100%; padding: 5px 0; border-top: 1px solid #eee; }
    .level-label { font-family: 'Fredoka One'; font-size: 0.9rem; color: #555; width: 60px; }
    input[type=range] { flex: 1; -webkit-appearance: none; width: 100%; height: 6px; background: #ddd; border-radius: 5px; outline: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; border-radius: 50%; background: var(--lvl-1); cursor: pointer; transition: background 0.3s; }
    
    .lvl-1::-webkit-slider-thumb { background: var(--lvl-1) !important; } .lvl-2::-webkit-slider-thumb { background: var(--lvl-2) !important; }
    .lvl-3::-webkit-slider-thumb { background: var(--lvl-3) !important; } .lvl-4::-webkit-slider-thumb { background: var(--lvl-4) !important; }
    .lvl-5::-webkit-slider-thumb { background: var(--lvl-5) !important; } .lvl-6::-webkit-slider-thumb { background: var(--lvl-6) !important; }
    .lvl-7::-webkit-slider-thumb { background: var(--lvl-7) !important; } .lvl-8::-webkit-slider-thumb { background: var(--lvl-8) !important; }
    .lvl-9::-webkit-slider-thumb { background: var(--lvl-9) !important; }

    /* CONTROLS */
    .controls-container { display: flex; flex-direction: column; gap: 5px; width: 100%; }
    .control-row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding: 2px 0; }
    .control-row:not(:last-child) { border-bottom: 1px dashed #eee; }

    .toggle-group { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; font-weight: bold; color: #555; cursor: pointer; background: #fff; padding: 3px 8px; border-radius: 12px; border: 1px solid #eee; transition: all 0.3s; }
    .switch { position: relative; display: inline-block; width: 28px; height: 16px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
    .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: #333; }
    input:checked + .slider:before { transform: translateX(12px); }
    
    /* Active State for Pronoun 'Radio' Buttons */
    input:checked + .slider.radio-slider { background-color: var(--pos-verb); }

    .toggle-group.disabled { opacity: 0.4; pointer-events: none; filter: grayscale(1); }

    /* CARD GRID */
    .container { max-width: 1200px; margin: 0 auto; padding: 30px 20px; }
    .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(170px, 1fr)); gap: 25px; }
    .vocab-card { aspect-ratio: 3/4; background-color: transparent; perspective: 1000px; cursor: pointer; }
    .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.06); }
    .vocab-card.flipped .card-inner { transform: rotateY(180deg); }
    .card-front, .card-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: 16px; overflow: hidden; background: var(--card-bg); display: flex; flex-direction: column; }
    .card-back { transform: rotateY(180deg); background: #fdfdfd; padding: 15px; box-sizing: border-box; align-items: center; justify-content: flex-start; }

    .card-art { flex: 1; width: 100%; display: flex; align-items: center; justify-content: center; padding: 15px; box-sizing: border-box; }
    .card-art img { max-width: 100%; max-height: 100%; object-fit: contain; filter: brightness(1.03) contrast(1.03); mix-blend-mode: multiply; }
    .card-obi { min-height: 80px; display: flex; flex-direction: column; align-items: center; justify-content: center; padding-bottom: 5px; position: relative; }
    .color-stroke { position: absolute; bottom: 0; left: 0; width: 100%; height: 6px; }
    
    .word-row { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; margin-bottom: 2px; }
    .word { font-size: 1.6rem; color: #333; text-align: center; line-height: 1.1; }
    .sub-word { font-size: 0.8rem; color: #777; font-family: 'Zen Maru Gothic'; text-align: center; font-weight: 500; }
    .gender-badge { font-size: 0.75rem; color: #999; font-style: italic; margin-top: 2px; font-family: 'Zen Maru Gothic'; }

    .pos-badge { font-size: 0.6rem; color: white; padding: 3px 8px; border-radius: 10px; font-family: 'Zen Maru Gothic'; font-weight: bold; letter-spacing: 0.5px; text-transform: lowercase; margin-top: 4px; display: none; }
    .pos-noun { background: var(--pos-noun); } .pos-verb { background: var(--pos-verb); } .pos-adj { background: var(--pos-adj); } .pos-pron { background: var(--pos-pron); }
    .show-pos .pos-badge { display: inline-block; }
    
    .flip-btn { position: absolute; top: 10px; right: 10px; width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.9); border: 1px solid #eee; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; cursor: pointer; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

    /* BACK TABLE: MATRIX */
    .back-title { font-family: 'Fredoka One'; font-size: 1rem; color: #333; margin-bottom: 10px; margin-top: 5px; }
    .comp-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; text-align: left; }
    .comp-table td { padding: 8px 4px; border-bottom: 1px solid #eee;}
    
    .verb-matrix { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; }
    .verb-cell { background: #f5f5f5; border-radius: 8px; padding: 8px; text-align: center; font-size: 0.8rem; display: flex; flex-direction: column; justify-content: center;}
    .verb-cell.active-cell { background: var(--pos-verb); color: white; box-shadow: 0 4px 10px rgba(244, 67, 54, 0.3); }
    .pron-label { font-size: 0.6rem; font-weight: bold; opacity: 0.7; margin-bottom: 2px; text-transform: uppercase; }

    .close-flip { margin-top: auto; padding: 8px 20px; border-radius: 20px; background: #eee; border: none; font-family: 'Fredoka One'; color: #555; cursor: pointer; }

    /* CHILD MODE */
    #child-mode { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #fff; z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .child-toggles { display: flex; flex-direction: column; gap: 5px; width: 90%; max-width: 400px; margin-bottom: 15px; background: #f9f9f9; padding: 10px; border-radius: 15px; }
    .focus-card { width: 85vw; max-width: 400px; aspect-ratio: 3/4; background: white; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.1); display: flex; flex-direction: column; overflow: hidden; }
    .focus-card img { flex: 1; object-fit: contain; padding: 40px; filter: brightness(1.03) contrast(1.03); mix-blend-mode: multiply; }
    .focus-card .word-box { height: 160px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 10px; box-sizing: border-box;}
    .focus-card h1 { font-size: 3.5rem; margin: 0; color: #333; line-height: 1; }
    .controls { margin-top: 30px; display: flex; gap: 20px; }
    .nav-btn { width: 70px; height: 70px; border-radius: 50%; border: none; font-size: 2rem; background: #f5f5f5; cursor: pointer; color: #333; }
    .play-btn { width: 90px; height: 90px; font-size: 3rem; background: #333; color: white; }

    /* PRINT */
    #print-area { display: none; }
    @media print {
        header, .container, #child-mode { display: none !important; }
        #print-area { display: block !important; width: 100%; height: 100%; }
        .grid-poker { display: grid; grid-template-columns: repeat(3, 63.5mm); grid-template-rows: repeat(3, 88.9mm); padding: 10mm; gap: 2mm; }
        .grid-poker img { flex: 1; width: 100%; object-fit: contain; padding: 10px; }
        .grid-poker .txt { height: 25mm; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 18pt; color: #333; margin-bottom: 2mm; text-align: center;}
        .grid-poker .bar { height: 3mm; width: 100%; position: absolute; bottom: 0; left: 0; }
        .layout-a4 .page { break-after: page; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; }
        .layout-a4 .txt { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 80pt; color: #333; text-align: center; }
        .layout-a4 .bar { width: 15px; height: 100%; position: static; }
    }
</style>
</head>
<body>

<header>
    <div class="top-row">
        <div style="font-weight:bold; font-size:1.2rem; color:#333; font-family:'Fredoka One'">ü¶Å TinyVocab</div>
        <select id="lang-select">
            <option value="en">üá¨üáß English</option>
            <option value="fr">üá´üá∑ French</option>
            <option value="de">üá©üá™ German</option>
            <option value="it">üáÆüáπ Italian</option>
            <option value="ru">üá∑üá∫ Russian</option>
            <option value="zh">üá®üá≥ Chinese</option>
            <option value="ja">üáØüáµ Japanese</option>
            <option value="ko">üá∞üá∑ Korean</option>
        </select>
        <div style="display:flex; gap:8px;">
            <button class="btn" onclick="startChild()">‚ñ∂ Child Mode</button>
        </div>
    </div>
    
    <div class="level-container">
        <div class="level-label" id="lvl-txt">Level 1</div>
        <input type="range" min="1" max="9" value="1" class="lvl-1" id="level-slider" oninput="updateLevel(this.value)">
    </div>

    <div class="controls-container" id="header-toggles"></div>
</header>

<div class="container">
    <div class="card-grid" id="grid"></div>
</div>

<div id="child-mode" style="display:none;">
    <button onclick="exitChild()" style="position:absolute; top:30px; right:30px; border:none; background:none; font-size:2rem; opacity:0.3; cursor:pointer;">‚úï</button>
    <div id="child-toggles" class="child-toggles"></div>
    <div class="focus-card" id="focus-display">
        <img id="c-img" src="">
        <div class="word-box">
            <h1 id="c-word">Word</h1>
            <h2 id="c-sub"></h2>
            <div id="c-pos" class="pos-badge"></div>
            <div id="c-gender" class="gender-badge" style="font-size: 1.2rem;"></div>
        </div>
        <div class="focus-stripe" id="c-stripe"></div>
    </div>
    <div class="controls">
        <button class="nav-btn" onclick="move(-1)">üëà</button>
        <button class="nav-btn play-btn" onclick="speakDrill()">üîä</button>
        <button class="nav-btn" onclick="move(1)">üëâ</button>
    </div>
</div>

<div id="print-area"></div>

<script>
    let deck = [];
    let currentIndex = 0;
    let currentLang = 'en';
    let currentLevel = 1;

    const pronLabels = ['I', 'You', 'He/She/It', 'We', 'You (pl)', 'They'];

    // GROUPS
    const groups = [
        { id: 'phon', keys: ['ipa', 'latin', 'pinyin', 'hiragana', 'hanja', 'traditional'] },
        { id: 'meta', keys: ['pos', 'gender'] },
        { id: 'pronoun', keys: ['pron_0', 'pron_1', 'pron_2', 'pron_3', 'pron_4', 'pron_5'] },
        { id: 'noun', keys: ['article', 'plural_noun'] },
        { id: 'verb', keys: [
            'pres_sim', 'pres_cont', 'fut_sim', 'past_sim', 'pres_perf', 
            'past_cont', 'pres_perf_cont', 'past_perf', 'fut_cont',
            'fut_perf', 'past_perf_cont', 'fut_perf_cont',
            'conjugate', 'past', 'future', 'imperative', 'conditional'
        ]},
        { id: 'adj',  keys: ['fem', 'neut', 'plural_adj', 'acc', 'dat', 'gen', 'ins', 'pre'] }
    ];

    const langConfig = {
        'en': ['pos', 'article', 'plural_noun', 'plural_adj', 'ipa', 
               'pron_0', 'pron_1', 'pron_2', 'pron_3', 'pron_4', 'pron_5',
               'pres_sim', 'pres_cont', 'fut_sim', 'past_sim', 'pres_perf', 'past_cont', 'pres_perf_cont', 'past_perf', 'fut_cont', 'fut_perf', 'past_perf_cont', 'fut_perf_cont'],
        'fr': ['pos', 'article', 'plural_noun', 'plural_adj', 'gender', 'ipa', 'fem', 'pron_0', 'pron_1', 'pron_2', 'pron_3', 'pron_4', 'pron_5', 'conjugate', 'past', 'future', 'imperative', 'conditional'],
        'de': ['pos', 'article', 'plural_noun', 'plural_adj', 'gender', 'ipa', 'fem', 'neut', 'acc', 'dat', 'gen'],
        'it': ['pos', 'article', 'plural_noun', 'plural_adj', 'gender', 'ipa', 'fem'],
        'ru': ['pos', 'plural_noun', 'plural_adj', 'gender', 'latin', 'ipa', 'fem', 'neut', 'acc', 'dat', 'gen', 'ins', 'pre'],
        'zh': ['pos', 'traditional', 'pinyin'],
        'ja': ['pos', 'hiragana'],
        'ko': ['pos', 'hanja']
    };

    const levelConfig = {
        'ipa': 1, 'pinyin': 1, 'latin': 1, 'hiragana': 1, 'hanja': 1, 'traditional': 1, 'gender': 1,
        'pos': 2, 'article': 2, 'plural_noun': 2, 
        'plural_adj': 3, 'fem': 3, 'neut': 3, 'conjugate': 3,
        'pron_0':3, 'pron_1':3, 'pron_2':3, 'pron_3':3, 'pron_4':3, 'pron_5':3,
        'pres_sim': 4, 'pres_cont': 4, 'fut_sim': 5, 'past_sim': 5, 'pres_perf': 6,
        'past_cont': 7, 'pres_perf_cont': 7, 'past_perf': 8, 'fut_cont': 8, 'fut_perf': 9, 'past_perf_cont': 9, 'fut_perf_cont': 9,
        'past': 4, 'future': 4, 'acc': 4, 'dat': 4, 'gen': 4, 'imperative': 5, 'conditional': 5, 'ins': 5, 'pre': 5
    };

    const toggleLabels = { 
        'pos': 'Part of Speech', 'gender':'Gender', 'article':'Article', 'plural_noun':'Plural (N)',
        'plural_adj': 'Plural (Adj)', 'fem': 'Fem', 'neut': 'Neut',
        'acc': 'Acc', 'dat': 'Dat', 'gen': 'Gen', 'ins': 'Ins', 'pre': 'Pre',
        'pron_0': 'I', 'pron_1': 'You', 'pron_2': 'He/It', 'pron_3': 'We', 'pron_4': 'Y\'all', 'pron_5': 'They',
        'pres_sim': 'Simple Pres', 'pres_cont': 'Pres Cont', 'fut_sim': 'Simple Fut', 'past_sim': 'Simple Past', 'pres_perf': 'Pres Perf',
        'past_cont': 'Past Cont', 'pres_perf_cont': 'Pres Perf Cont', 'past_perf': 'Past Perf', 'fut_cont': 'Fut Cont',
        'fut_perf': 'Fut Perf', 'past_perf_cont': 'Past Perf Cont', 'fut_perf_cont': 'Fut Perf Cont',
        'conjugate': 'Present', 'past': 'Past', 'future': 'Future', 'imperative': 'Cmd', 'conditional': 'Cond',
        'pinyin':'Pinyin', 'latin':'Latin', 'ipa':'IPA', 'hiragana':'Hiragana', 'hanja':'Hanja', 'traditional':'Traditional'
    };

    let toggleState = { 
        pos: false, gender: false, article: false, plural_noun: false, plural_adj: false,
        pron_0: false, pron_1: false, pron_2: true, pron_3: false, pron_4: false, pron_5: false,
        pres_sim: false, pres_cont: false, fut_sim: false, past_sim: false, pres_perf: false,
        past_cont: false, pres_perf_cont: false, past_perf: false, fut_cont: false, fut_perf: false, past_perf_cont: false, fut_perf_cont: false,
        conjugate: false, past: false, future: false, imperative: false, conditional: false,
        fem: false, neut: false, acc: false, dat: false, gen: false, ins: false, pre: false,
        pinyin: false, latin: false, ipa: false, hiragana: false, hanja: false, traditional: false
    };

    const colors = { animal: '#7CB342', food: '#FDD835', body: '#42A5F5', act: '#AB47BC' };

    function updateUI() {
    updateControls('header-toggles');
    renderGrid();
    
    // Also update the child mode display if it happens to be open
    if (document.getElementById('child-mode').style.display === 'flex') {
        updateDisplay();
    }
}
    // --- ROBUST FETCH WITH ERROR HANDLING ---
    fetch('data.json')
        .then(res => {
            if (!res.ok) throw new Error("HTTP error " + res.status);
            return res.json();
        })
        .then(data => { 
            deck = data; 
            updateUI(); 
        })
        .catch(err => { 
            console.error("JSON Load Error:", err);
            document.getElementById('grid').innerHTML = `
                <div style="grid-column: 1 / -1; background: #ffebee; color: #c62828; padding: 20px; border-radius: 10px; text-align: center; font-family: 'Fredoka One'; font-size: 1.5rem;">
                    ‚ö†Ô∏è Error loading data.json!<br>
                    <span style="font-family: 'Zen Maru Gothic'; font-size: 1rem; font-weight: normal;">Please check if the file exists and has correct JSON formatting (no missing brackets or extra commas).</span>
                </div>`;
        });

    document.getElementById('lang-select').addEventListener('change', (e) => {
        currentLang = e.target.value;
        Object.keys(toggleState).forEach(k => toggleState[k] = false);
        toggleState.pron_2 = true; // Always default to He/She
        updateUI();
    });

    function updateLevel(val) {
        currentLevel = parseInt(val);
        document.getElementById('lvl-txt').innerText = `Level ${currentLevel}`;
        document.getElementById('level-slider').className = `lvl-${currentLevel}`;
        updateUI();
    }

    function getFontClass() {
        if (currentLang === 'ja') return 'font-ja';
        if (currentLang === 'ko') return 'font-ko';
        if (currentLang === 'zh') return toggleState.traditional ? 'font-zh-tw' : 'font-zh-cn';
        return 'font-en';
    }

    function updateControls(containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        const allowed = langConfig[currentLang];

        groups.forEach(grp => {
            const validKeys = grp.keys.filter(k => allowed.includes(k) && currentLevel >= levelConfig[k]);
            if (validKeys.length > 0) {
                const row = document.createElement('div'); row.className = 'control-row';
                validKeys.forEach(key => {
                    const isPronoun = key.startsWith('pron_');
                    const sliderClass = isPronoun ? 'slider radio-slider' : 'slider';
                    const inputID = `chk-${containerId}-${key}`;
                    const html = `
                        <label class="toggle-group" id="lbl-${containerId}-${key}">
                            <span class="switch"><input type="checkbox" id="${inputID}" data-key="${key}" onchange="toggleFeature('${key}', this.checked)" ${toggleState[key]?'checked':''}>
                            <span class="${sliderClass}"></span></span>${toggleLabels[key]}
                        </label>`;
                    row.insertAdjacentHTML('beforeend', html);
                });
                container.appendChild(row);
            }
        });
        checkDependency();
    }

    window.toggleFeature = function(key, isChecked) {
        if(key.startsWith('pron_') && isChecked) {
            for(let i=0; i<=5; i++) toggleState[`pron_${i}`] = false;
            toggleState[key] = true;
        } else if (key.startsWith('pron_') && !isChecked) {
            document.querySelector(`input[data-key="${key}"]`).checked = true;
            return;
        } else {
            toggleState[key] = isChecked;
        }
        
        if(isChecked && !key.startsWith('pron_')) {
            const enTenses = ['pres_sim', 'pres_cont', 'fut_sim', 'past_sim', 'pres_perf', 'past_cont', 'pres_perf_cont', 'past_perf', 'fut_cont', 'fut_perf', 'past_perf_cont', 'fut_perf_cont'];
            if(enTenses.includes(key)) enTenses.forEach(k => { if(k !== key) toggleState[k] = false; });

            const adjMut = ['fem', 'neut', 'acc', 'dat', 'gen', 'ins', 'pre'];
            if(adjMut.includes(key)) adjMut.forEach(k => { if(k !== key) toggleState[k] = false; });
            
            const verbMut = ['conjugate', 'past', 'future', 'imperative', 'conditional'];
            if(verbMut.includes(key)) verbMut.forEach(k => { if(k !== key) toggleState[k] = false; });
        }

        document.querySelectorAll(`input[data-key]`).forEach(el => {
            const k = el.getAttribute('data-key');
            el.checked = toggleState[k];
        });

        if(key==='plural_noun') checkDependency();
        renderGrid();
        if(document.getElementById('child-mode').style.display === 'flex') updateDisplay();
    };

    function checkDependency() {
        const isPlural = toggleState.plural_noun;
        const artInputs = document.querySelectorAll(`input[data-key="article"]`);
        if (isPlural) {
            toggleState.article = false;
            artInputs.forEach(el => { el.checked = false; el.disabled = true; });
        } else {
            artInputs.forEach(el => { el.disabled = false; });
        }
    }

    function getActivePronounIdx() {
        for(let i=0; i<=5; i++) if(toggleState[`pron_${i}`]) return i;
        return 2;
    }

    function extractText(data) {
        if(!data) return null;
        if(Array.isArray(data)) return data[getActivePronounIdx()];
        return data; 
    }

    function getActiveTenseKey() {
        const keys = ['pres_sim', 'pres_cont', 'fut_sim', 'past_sim', 'pres_perf', 'past_cont', 'pres_perf_cont', 'past_perf', 'fut_cont', 'fut_perf', 'past_perf_cont', 'fut_perf_cont', 'conjugate', 'past', 'future', 'imperative', 'conditional'];
        for(let k of keys) { if(toggleState[k]) return k; }
        return null;
    }

    function getTextDisplay(card) {
        let raw = card.translations[currentLang]; 
        if (!raw) raw = card.translations['en']; // Fallback
        if (!raw || typeof raw === 'string') return { main: raw || '?', sub: '', gender: '' };

        let mainText = (currentLang === 'zh' && toggleState.traditional && raw.t) ? raw.t : (raw.n || '?');
        let genderText = (toggleState.gender && raw.g) ? raw.g : '';
        let subText = '';

        if (card.pos === 'noun') {
            if (toggleState.plural_noun && raw.p) mainText = raw.p;
            if (toggleState.article && !toggleState.plural_noun && raw.art) mainText = `${raw.art} ${mainText}`;
        }

        if (card.pos === 'verb') {
            const activeTense = getActiveTenseKey();
            if (activeTense) {
                // Fixed: Map 'conjugate' to 'pres' for legacy langs
                const jsonKey = activeTense === 'conjugate' ? 'pres' : activeTense;
                if (raw[jsonKey]) {
                    const result = extractText(raw[jsonKey]);
                    if(result) mainText = result;
                }
            }
        }

        if (card.pos === 'adj') {
            if (toggleState.acc && raw.acc) mainText = raw.acc;
            else if (toggleState.dat && raw.dat) mainText = raw.dat;
            else if (toggleState.gen && raw.gen) mainText = raw.gen;
            else if (toggleState.ins && raw.ins) mainText = raw.ins;
            else if (toggleState.pre && raw.pre) mainText = raw.pre;
            else if (toggleState.plural_adj) {
                if (toggleState.fem && raw.fp) mainText = raw.fp;
                else if (raw.mp) mainText = raw.mp;
                else if (raw.p) mainText = raw.p;
            } 
            else if (toggleState.fem && raw.f) mainText = raw.f;
            else if (toggleState.neut && raw.nt) mainText = raw.nt;
        }

        if (toggleState.pinyin && raw.py) subText = raw.py;
        if (toggleState.latin && raw.lt) subText = raw.lt;
        if (toggleState.ipa && raw.ipa) subText = `[${raw.ipa}]`;
        if (currentLang === 'ja' && toggleState.hiragana && raw.r) subText = `(${raw.r})`;
        if (currentLang === 'ko' && toggleState.hanja && raw.hj) { subText = `(${mainText})`; mainText = raw.hj; }

        return { main: mainText, sub: subText, gender: genderText };
    }

    function buildBackTable(card) {
        if(card.pos === 'verb' && currentLevel >= 3) {
            const raw = card.translations[currentLang] || card.translations['en'];
            // Safe fallback if language doesn't have the tense
            let activeTense = getActiveTenseKey();
            if (!activeTense) { activeTense = (currentLang === 'en') ? 'pres_sim' : 'conjugate'; }
            
            const jsonKey = activeTense === 'conjugate' ? 'pres' : activeTense;
            const tenseData = raw ? raw[jsonKey] : null;
            const activeIdx = getActivePronounIdx();
            const tenseTitle = toggleLabels[activeTense] || 'Infinitive';

            if(Array.isArray(tenseData)) {
                let cellsHTML = '';
                for(let i=0; i<6; i++) {
                    const isActive = i === activeIdx ? 'active-cell' : '';
                    cellsHTML += `
                        <div class="verb-cell ${isActive}">
                            <div class="pron-label">${pronLabels[i]}</div>
                            <div class="font-${currentLang}">${tenseData[i]}</div>
                        </div>`;
                }
                return `<div class="back-title">${tenseTitle} Matrix</div>
                        <div class="verb-matrix">${cellsHTML}</div>`;
            } else {
                return `<div class="back-title">Info</div><p style="font-size:0.8rem; color:#666; padding:10px;">Full conjugation matrix not added for this word/tense yet.</p>`;
            }
        } else {
            return `<div class="back-title">Gender Compare</div>
                    <table class="comp-table">
                        ${buildCompRow(card, 'fr', 'üá´üá∑')}${buildCompRow(card, 'de', 'üá©üá™')}
                        ${buildCompRow(card, 'it', 'üáÆüáπ')}${buildCompRow(card, 'ru', 'üá∑üá∫')}
                    </table>`;
        }
    }

    function renderGrid() {
        const fontClass = getFontClass();
        document.getElementById('grid').innerHTML = deck.map(card => {
            const txt = getTextDisplay(card);
            const col = colors[card.cat] || '#ccc';
            const posClass = `pos-${card.pos || 'noun'}`;
            const posVisibility = toggleState.pos ? 'show-pos' : '';

            return `
            <div class="vocab-card" onclick="startChildAt('${card.id}')">
                <div class="card-inner" id="card-${card.id}">
                    <div class="card-front">
                        <div class="flip-btn" onclick="flipCard(event, '${card.id}')">üîÑ</div>
                        <div class="card-art"><img src="${card.img}" onerror="this.src='https://via.placeholder.com/300'" loading="lazy"></div>
                        <div class="card-obi ${posVisibility}">
                            <div class="word-row">
                                <div class="word ${fontClass}">${txt.main}</div>
                            </div>
                            <div class="pos-badge ${posClass}">${card.pos || ''}</div>
                            ${txt.sub ? `<div class="sub-word">${txt.sub}</div>` : ''}
                            <div class="color-stroke" style="background:${col}"></div>
                        </div>
                    </div>
                    <div class="card-back">
                        ${buildBackTable(card)}
                        <button class="close-flip" onclick="flipCard(event, '${card.id}')">Close</button>
                    </div>
                </div>
            </div>`;
        }).join('');
    }

    function startChildAt(id) { currentIndex = deck.findIndex(c => c.id === id); startChild(); }
    function startChild() { if(deck.length>0){ document.getElementById('child-mode').style.display = 'flex'; updateUI(); updateDisplay(); } }
    function exitChild() { document.getElementById('child-mode').style.display = 'none'; window.speechSynthesis.cancel(); }
    
    function updateDisplay() {
        const card = deck[currentIndex];
        const txt = getTextDisplay(card);
        const col = colors[card.cat] || '#333';
        
        document.getElementById('c-word').className = getFontClass();
        document.getElementById('c-img').src = card.img;
        document.getElementById('c-word').innerText = txt.main;
        document.getElementById('c-sub').innerText = txt.sub;
        document.getElementById('c-stripe').style.background = col;
        
        const posEl = document.getElementById('c-pos');
        posEl.className = `pos-badge pos-${card.pos || 'noun'}`;
        posEl.innerText = card.pos || '';
        posEl.style.display = toggleState.pos ? 'inline-block' : 'none';
    }

    function move(dir) { window.speechSynthesis.cancel(); currentIndex = (currentIndex + dir + deck.length) % deck.length; updateDisplay(); }
    function getGenderClass(g) { if(!g)return''; if(g.includes('masc'))return'g-masc'; if(g.includes('fem'))return'g-fem'; if(g.includes('neut'))return'g-neut'; return ''; }
    function buildCompRow(c,l,f) { const d=c.translations[l]; if(!d)return''; const g=getGenderClass(d.g||''); return `<tr><td style="width:30px">${f}</td><td class="${g}" style="font-weight:bold">${d.art||''}</td><td class="${g}">${d.n||''}</td></tr>`; }
    window.flipCard = function(e, id) { e.stopPropagation(); const p=document.getElementById(`card-${id}`).parentElement; if(p.classList.contains('flipped'))p.classList.remove('flipped'); else {document.querySelectorAll('.vocab-card').forEach(c=>c.classList.remove('flipped')); p.classList.add('flipped');} };

    function speakDrill() {
        const card = deck[currentIndex]; const txt = getTextDisplay(card);
        const voice = window.speechSynthesis.getVoices().find(v => v.lang.includes({'en':'en-GB', 'fr':'fr-FR'}[currentLang]||'en-US')) || window.speechSynthesis.getVoices()[0];
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(txt.main); u.voice=voice; u.rate=0.9; window.speechSynthesis.speak(u);
    }
</script>
</body>
</html>